## 选择排序

#### 算法描述
1.在未排序的数组中找到Min(or Max)元素,然后和数组的第一个元素
交换位置。

2.再从剩余的未排序数组中继续寻找Min(or Max)元素,然后继续和剩余的未排序数组的
第一个元素交换位置。

3.以此类推，直到所有位置均排序完毕。

**简而言之,选择排序的由来是因为它不断地从剩余的元素中选择其最值**

[算法的执行原理过程](http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/)

```
 public static void selectionSort(int[] arr){
    
    for(int i = 0; i < arr.length; i++){
        // 外循环
        int minIndex = i;
        for(int j = i; j < arr.length; j++){
            // 内循环 
            if(arr[j] < arr[minIndex]){
                minIndex = j;
            }
        }
        
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
 
 }
```

从上述代码中，可以看出：
>选择排序的**内循环**只是在通过**比较**，进而找出数组的最小值(以及更新索引和检查数组越界)；

>**外循环**主要是和最小值**交换**元素。

因此：若对于长度为n的数组，选择排序需要大约 n²/2次比较和 n 次交换。
0 ~ n -1 的任意i都会进行 1 次交换 和 n -1 - i 次比较。故共有n次交换及(n-1)+(n-2)+...
+1 = n(n-1)/2 ~  n²/2次比较。

#### 复杂度分析
>比较次数O(n²),且比较次数与关键字的初始状态无关，总的比较次数N  = (n-1)+(n-2)+...
                                       +1 = n(n-1)/2

> 交换次数O(n),最好情况是已经有序，交换0次；最坏情况，逆序,交换 n -1次。

>**选择排序**的交换次数比**冒泡排序**少。但由于交换所需的CPU时间 比 比较所需的CPU时间多。
**故n值较少时，选择排序比冒泡排序快**。

**原地操作几乎是选择排序的唯一优点,当空间复杂度要求较高时，可以考虑选择排序**

[选择排序的Wiki](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)

我们知道**选择排序**跟数据元素的初始状态无关。无论是有序的or主键全部相等的数组，其运行时间
是一样的。这就是它的不足。所以我们要寻找更善于利用数据的初始状态的排序算法。

**选择排序节省空间**